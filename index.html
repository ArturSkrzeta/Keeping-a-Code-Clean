<!DOCTYPE HTML>

<html>
	<head>
		<title>Portfolio Artur Skrzeta</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
	</head>
	<body class="is-preload">

		<!-- Header -->
			<section id="header">
				<header>
					<span class="image avatar"><a href="https://arturskrzeta.github.io/"><img src="images/avatar.png" alt="" style="margin-bottom:0px;"/></a></span>
					<h1 id="logo"><a href="https://arturskrzeta.github.io/">Artur Skrzeta</a></h1>
					<p>Data Analyst<br />
					+4 years experience</p>
				</header>
				<nav id="nav">
					<ul>
						<li><a href="#one" class="active">Intro</a></li>
						<li><a href="#two">Features</a></li>
						<li><a href="#three">Demo</a></li>
						<li><a href="#four">Setup</a></li>
						<li><a href="#five">Source Code</a></li>
					</ul>
				</nav>
				<footer>
					<ul class="icons">
						<li><a href="https://www.linkedin.com/in/artur-skrz%C4%99ta-010b23187/" class="icon brands fa-linkedin"><span class="label">LinkedIn</span></a></li>
						<li><a href="https://www.instagram.com/arturskrrr/" class="icon brands fa-instagram"><span class="label">Instagram</span></a></li>
						<li><a href="https://github.com/ArturSkrzeta" class="icon brands fa-github"><span class="label">Github</span></a></li>
						<li><a href="mailto: arturskrzeta@gmail.com" class="icon solid fa-envelope"><span class="label">Email</span></a></li
					</ul>
				</footer>
			</section>

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<div id="main">

						<!-- One -->
							<section id="one">
								<div class="container">
									<header class="major">
										<h2>Keeping Python Code Clean</h2>
										<h3>Intro</h3>
										<p>In this section, I try my best to collect and describe and first of all put down my understanding on how to implement all the techniques that contribute to the clean code of an application.<br>
											I touch here both theoretical principles and libraries that assists with feedback on Python's syntax.</p>
									</header>
								</div>
							</section>

						<!-- Two -->
							<section id="two">
								<div class="container">
									<h3>Features</h3>
									<p>App includes following features:</p>
									<ul class="feature-icons">
										<li class="icon solid fa-check">SOLID</li>
										<li class="icon solid fa-check">DRY</li>
										<li class="icon solid fa-check">KIS</li>
									</ul>
								</div>
							</section>

						<!-- Three -->
							<section id="three">
								<div class="container">
									<h3>Demo</h3>

									<h5>In this section I describe following concepts:</h5>
									<ul>
										<li>SOLID</li>
										<li>DRY</li>
										<li>KIS</li>
									</ul>

									<p style="font-size:22px; border-bottom: 1px solid #cacaca; padding-bottom:4px;"><b>SOLID</b></p>

									<p>SOLID is the set of good practicies that lead us to properly desing software keeping to the concept of the Object-orinted programming.</p>

									<h5>Terminology:</h5>
									<ul>
										<li><b>Abstract class</b> is a class that contains one or more abstract methods. They cannot be instantiated and they require subclasses to provide implementations for their abstract methods.</li>
										<li><b>Abstract method</b> is a method that is declared, but contains no implementation. Needs to be implemented by subclasses that inherits them.

<!-- code area start -->
<pre>
from abc import ABC, abstractmethod

class <span style="color:#00ffea">Save</span>(ABC):

@abstractmethod
def save_data(self):
	print("Saving data...")

class SaveToDb(<span style="color:#00ffea">Save</span>):

def save_data(self):
	super().do_something()
	print("to database.")

x = SaveToDb()
x.save_data()

-------------------------
# output:
# Saving data...
# to database.</pre>
<!-- code area stop -->

											- <b>Save</b> abstract class defines abstract method <b>save_data</b>,<br>
											- <b>SaveToDb</b> class implements <b>save_data</b> method and extends it with additional functionality.
										</li>
										<li><b>Inheritance</b> - child class inherits all of the attributes and methods of parent class.
												However, everything that is inherited by child class can be extended in order to fit requirements that child class has to fulfil.
												In such case there in a need to re-implement the method in the child class which is called the <b>method overriding</b>.
												In the above code section, the child class SaveToDb inherits from the parent class Save.</li>
										<li><b>Polymorphism</b> - naming methods the same in child class means that the same function can be used by different types/classes that inheritns from a base class .</li>
									</ul>

									<h5>Single Responsibility Principle (SRP):</h5>
									<ul>
										<li><code>Every class should only have one responsibility</code><br>
												<code>and therefore only one reason to change.</code></li>
										<li>In other words, a class is responsible for performing only one specified task.</li>
										<li>Too many tasks within a class would cause to much complexity and change of one task can affect another task's work.</li>
										<li>When multiple tasks in a class and there is a new requirement from the business, it forces us to modify existing code which violates rest of SOLID principles.</li>
										<li>With this SRP, maintaining the code is much easier and readable when handing code over.</li>
										<li>When class perfoms only one task, it is much easiser to test it out.</li>
										<li>SRP enables flexibility in extending the application with new business requirements.</li>
									</ul>

									<h5>Open Closed Principle (OCP):</h5>
									<ul>
										<li><code>Software Entities (classes, functions, modules)</code><br>
												<code>should be open for extension but closed to change.</code></li>
										<li>Without OCP, when a new business requirement comes in, the most common approach is modifing the definition of existing method.</li>
										<li>Keeping modifying definition of extisting functunality we end up testing the enire scope repeatedly.</li>
										<li>When following OCP, instead of modifying, we should extend the aplication to satisfy the new requirement.</li>
										<li>Avoiding modifying, we are less likely to introduce some bugs into the existing code as well as we avoinding redeploying the same code again and again.</li>
										<li>Extension can be achieved by inheritance from parent class where child class satisfies a new requirement.
											<br>
											- child class extends existing parent classes,<br>
											- child class can override definition of parent's methods which covers a new requirements.
										</li>
										<li>We can be keeping an abstract class - the most general one that will never be instantiated but will be a pattern to inherit from by sub-classes where each sub-class answers specific business requirement.</li>
									</ul>

									<h5>Liskov's Substitution Principle (LSP):</h5>
									<ul>
										<li><code>If S is a subtype of T, then objects of type T</code><br>
												<code>may be replaced with objects of Type S.</code></li>
										<li>This principle is strictly related to proper inheritnace where any child class can replace its parent class without breaking functionality.
<!-- code area start -->
<pre>
class <span style="color:#00ffea">Vehicle</span>:
def count_wheels(self):
	pass

class Car(<span style="color:#00ffea">Vehicle</span>):
def count_wheels(self):
	pass

class Truck(<span style="color:#00ffea">Vehicle</span>):
def count_wheels(self):
	pass

def vehicle_wheels_count(<span style="color:#ffe200">vehicles</span>):
for viehicle in <span style="color:#ffe200">vehicles</span>:
	print(viehicle.count_wheels())

def main():
<span style="color:#ffe200">vehicles</span> = [Car(), Car(), Truck()]
vehicle_wheels_count(<span style="color:#ffe200">vehicles</span>)</pre>
<!-- code area stop -->
												- <b>Vehicle</b> class defines count_wheels method,<br>
												- every child class that inherits from Vehicle parent class implements <b>count_wheels</b> method,<br>
												- count_wheels method can be extended due to subclass's specification as car's wheels will be counted differently than truck's wheels,<br>
												- the method <b>vehicle_wheels_count</b> doesn't care about type of passed object, it just calls count_wheels method on every object of the passed list,<br>
												- all the method vehicle_wheels_count knows is that each object in the passed list must be of the Vehicle type, regardless of it is from Vehicle parent's class itself or from child class (Car, Truck).
										</li>
									</ul>

									<h5>Interface Segregation Principle (ISP):</h5>
									<ul>
										<li><code>Clients should not be forced to depend upon interfaces that they do not use</code></li>
										<li>Interface is a class-like structure that lists what methods needs to be implemented by a class that makes usage of this interface.
												Like I said, it only indicates the methods, interface doesn't define their implementation - this is job for the class. </li>
										<li>In Python, there is no interface as such. However, Python allows to implement abstract class with usage of abc module.
											<br>
											- we cannot instantiate an abstract class,<br>
											- abstract class defines methods that needs to be implemented in all of the child classes that inherits from it,<br>
											- with using abract classes we can be creating Python's interface-like structures.
										</li>
										<li>Lets set up scenario where there is a big interace that has multiple abstract methods:
											<br>
											- class that uses that interface needs to implement all of the abstract methods (in Python, it is required by decorator @abstractmethod),<br>
											- however, there may be some abstract methods that our specific class doesn't need to implement,<br>
											- implementing needless method or implementing it as <code>pass</code> violates SOLID principles,<br>
											- following ISP, we would need to divide one main interface to several ones due to their functionality so that classes tha would use them can implement only methods that they need.
										</li>
									</ul>

									<h5>Dependency Inversion Principle (DIP)</h5>
									<ul>
										<li><code>High-level modules should not depend upon low-level modules.</code><br>
												<code>Both low and high level classes should depend on the same abstractions.</code><br>
												<code>Abstractions should not depend on details.</code><br>
												<code>Details should depend upon abstractions.</code><br>
										</li>
										<li>There are some characteristic terms for a bad code design:
											<br>
											- <b>Rigidity:</b> when it's hard to do some changes to the code as they affect to many parts of the application. When change necessary, it forces us to modify another dependent part of the code. Furthermore, it causes hardships with time and costs estimation for changes implementation,<br>
											- <b>Fragility:</b> when changes being implemented causes crash of app's parts that we did not expect. It lowers trust in the project that uses the code because each another change can cause avalanche of errors from unknown sides,<br>
											- <b>Immobility:</b> when it's impossible to use the code in another application as it's very difficult to extract it. Difficulties result from too big dependecny of code section against other ones. It happens that finding dependecies and extracting the code for reusing is more time consuming than writing it from scratch.
										</li>
										<li>Abstractions need to be organized is such way they don't depend on details (concrete implementations) but rather other way around - the implementations should depend on abstractions.</li>
										<li>The main assumption over here is that implementations changes more often than the abstraction they were created on.</li>
										<li>Low-level modules are sub-modules of a high-level module which in turn can be the low-level module for another module.</li>
										<li>Lets take two classes A and B as the example:
											<br>
											- A depends on B, when B changes, it crashes the code,<br>
											- we need to invert the dependencies and make B to adopt to A,<br>
											- this can be achieved by implementing interface (abstract class A) and forcing code to depend on defined interface instead of a specific implementation (class B),<br>
											- while we expect implementations to change frequently, the abstraction stays unchanged.
										</li>
									</ul>

									<p style="font-size:22px; border-bottom: 1px solid #cacaca; padding-bottom:4px;"><b>DRY</b></p>

									<h5>Don't Repeat Yourself</h5>
									<ul>
										<li>This is general language-independent principle that aims at reducing repititions in the source code.</li>
										<li>The same code snippet repeated in different places of the code makes project hard to mantian.
												Even one small change or a new business requirement would force us to come through and update every section that change concerns.</li>
										<li>The simplest way to keep a code DRY is to delegate as much repetative functionalities as possible to an external reusable function.
												And then whenever I need this functionality to implement, I simply call the function.</li>
										<li>With that solution, whenever I need to update some functionality, I just do this once in the function that provides is instead of going to each place it's implemented.</li>
										<li>Code example:
<!-- code area start -->
<pre>
def <span style="color:#ffe200">save_to_db()</span> -> None:
  db.commit()
  db.save()
  print("saved to db")

def enter_data() -> None:
  validate_data()
  <span style="color:#ffe200">save_to_db()</span>

def exit_app() -> None:
  <span style="color:#ffe200">save_to_db()</span>
  logout()
</pre>
<!-- code area stop -->
											- Above method save_to_db is reused in another app's methods where is a need to save some data to database.<br>
											- Hence, only method save_to_db contains all the logic an functionality of saving data to database.
										</li>
									</ul>

									<p style="font-size:22px; border-bottom: 1px solid #cacaca; padding-bottom:4px;"><b>KIS</b></p>

								</div>
							</section>

						<!-- Four -->
							<section id="four">
								<div class="container">
									<h3>Setup</h3>
									<p>No specific installation required.</p>
								</div>
							</section>

						<!-- Five -->
							<section id="five">
								<div class="container">
									<h3>Source Code</h3>
									<p>You can view the source code: <a href="#">HERE</a></p>
									<p>&nbsp</p>
								</div>
							</section>

					</div>

				<!-- Footer -->
					<section id="footer">
						<div class="container">
							<a href="https://arturskrzeta.github.io/" style="padding-bottom:10px;">Back to Portfolio</a>
						</div>
					</section>

			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>
