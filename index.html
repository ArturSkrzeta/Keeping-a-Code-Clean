<!DOCTYPE HTML>

<html>
	<head>
		<title>Portfolio Artur Skrzeta</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
	</head>
	<body class="is-preload">

		<!-- Header -->
			<section id="header">
				<header>
					<span class="image avatar"><a href="https://arturskrzeta.github.io/"><img src="images/avatar.png" alt="" style="margin-bottom:0px;"/></a></span>
					<h1 id="logo"><a href="https://arturskrzeta.github.io/">Artur Skrzeta</a></h1>
					<p>Data Analyst<br />
					+4 years experience</p>
				</header>
				<nav id="nav">
					<ul>
						<li><a href="#one" class="active">Intro</a></li>
						<li><a href="#two">Features</a></li>
						<li><a href="#three">Demo</a></li>
						<li><a href="#four">Setup</a></li>
						<li><a href="#five">Source Code</a></li>
					</ul>
				</nav>
				<footer>
					<ul class="icons">
						<li><a href="https://www.linkedin.com/in/artur-skrz%C4%99ta-010b23187/" class="icon brands fa-linkedin"><span class="label">LinkedIn</span></a></li>
						<li><a href="https://www.instagram.com/arturskrrr/" class="icon brands fa-instagram"><span class="label">Instagram</span></a></li>
						<li><a href="https://github.com/ArturSkrzeta" class="icon brands fa-github"><span class="label">Github</span></a></li>
						<li><a href="mailto: arturskrzeta@gmail.com" class="icon solid fa-envelope"><span class="label">Email</span></a></li
					</ul>
				</footer>
			</section>

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<div id="main">

						<!-- One -->
							<section id="one">
								<div class="container">
									<header class="major">
										<h2>Keeping a Code Clean</h2>
										<h3>Intro</h3>

										<h3>SOLID</h3>

										<h5>Terminology:</h5>
										<ul>
											<li><b>Abstract class</b> is a class that contains one or more abstract methods. They cannot be instantiated and they require subclasses to provide implementations for their abstract methods.</li>
											<li><b>Abstract method</b> is a method that is declared, but contains no implementation. Needs to be implemented by subclasses that inherits them.

<!-- code area start -->
<pre>from abc import ABC, abstractmethod

class <span style="color:#00ffea">Save</span>(ABC):

  @abstractmethod
  def save_data(self):
    print("Saving data...")

class SaveToDb(<span style="color:#00ffea">Save</span>):

  def save_data(self):
    super().do_something()
    print("to database.")

x = SaveToDb()
x.save_data()

-------------------------
# output:
# Saving data...
# to database.</pre>
<!-- code area stop -->

												- <b>Save</b> abstract class defines abstract method <b>save_data</b>,<br>
												- <b>SaveToDb</b> class implements <b>save_data</b> method and extends it with additional functionality.
											</li>
											<li><b>Inheritance</b> - child class inherits all of the attributes and methods of parent class.
													However, everything that is inherited by child class can be extended in order to fit requirements that child class has to fulfil.
													In such case there in a need to re-implement the method in the child class which is called the <b>method overriding</b>.
												 	In the above code section, the child class SaveToDb inherits from the parent class Save.</li>
											<li><b>Polymorphism</b> - naming methods the same in child class means that the same function can be used by different types/classes that inheritns from a base class .</li>
										</ul>

										<h5>Single Responsibility Principle (SRP):</h5>
										<ul>
											<li><code>Every class should only have one responsibility</code><br>
													<code>and therefore only one reason to change.</code></li>
											<li>In other words, a class is responsible for performing only one specified task.</li>
											<li>Too many tasks within a class would cause to much complexity and change of one task can affect another task's work.</li>
											<li>When multiple tasks in a class and there is a new requirement from the business, it forces us to modify existing code which violates rest of SOLID principles.</li>
											<li>With this SRP, maintaining the code is much easier and readable when handing code over.</li>
											<li>When class perfoms only one task, it is much easiser to test it out.</li>
											<li>SRP enables flexibility in extending the application with new business requirements.</li>
										</ul>

										<h5>Open Closed Principle (OCP):</h5>
										<ul>
											<li><code>Software Entities (classes, functions, modules)</code><br>
													<code>should be open for extension but closed to change.</code></li>
											<li>Without OCP, when a new business requirement comes in, the most common approach is modifing the definition of existing method.</li>
											<li>Keeping modifying definition of extisting functunality we end up testing the enire scope repeatedly.</li>
											<li>When following OCP, instead of modifying, we should extend the aplication to satisfy the new requirement.</li>
											<li>Avoiding modifying, we are less likely to introduce some bugs into the existing code as well as we avoinding redeploying the same code again and again.</li>
											<li>Extension can be achieved by inheritance from parent class where child class satisfies a new requirement.
												<br>
												- child class extends existing parent classes,<br>
												- child class can override definition of parent's methods which covers a new requirements.
											</li>
											<li>We can be keeping an abstract class - the most general one that will never be instantiated but will be a pattern to inherit from by sub-classes where each sub-class answers specific business requirement.</li>
										</ul>

										<h5>Liskov's Substitution Principle (LSP):</h5>
										<ul>
											<li><code>If S is a subtype of T, then objects of type T</code><br>
													<code>may be replaced with objects of Type S.</code></li>
											<li>This principle is strictly related to proper inheritnace where any child class can replace its parent class without breaking functionality.
<!-- code area start -->
<pre>
class <span style="color:#00ffea">Vehicle</span>:
  def count_wheels(self):
    pass

class Car(<span style="color:#00ffea">Vehicle</span>):
  def count_wheels(self):
    pass

class Truck(<span style="color:#00ffea">Vehicle</span>):
  def count_wheels(self):
    pass

def vehicle_wheels_count(<span style="color:#ffe200">vehicles</span>):
  for viehicle in <span style="color:#ffe200">vehicles</span>:
    print(viehicle.count_wheels())

def main():
	<span style="color:#ffe200">vehicles</span> = [Car(), Car(), Truck()]
	vehicle_wheels_count(<span style="color:#ffe200">vehicles</span>)</pre>
<!-- code area stop -->
													- <b>Vehicle</b> class defines count_wheels method,<br>
													- every child class that inherits from Vehicle parent class implements <b>count_wheels</b> method,<br>
													- count_wheels method can be extended due to subclass's specification as car's wheels will be counted differently than truck's wheels,<br>
													- the method <b>vehicle_wheels_count</b> doesn't care about type of passed object, it just calls count_wheels method on every object of the passed list,<br>
													- all the method vehicle_wheels_count knows is that each object in the passed list must be of the Vehicle type, regardless of it is from Vehicle parent's class itself or from child class (Car, Truck).
											</li>
										</ul>

										<h5>Interface Segregation Principle (ISP):</h5>
										<ul>
											<li><code>Clients should not be forced to depend upon interfaces that they do not use</code></li>
											<li>Interface is a class-like structure that lists what methods needs to be implemented by a class that makes usage of this interface.
													Like I said, it only indicates the methods, interface doesn't define their implementation - this is job for the class. </li>
											<li>In Python, there is no interface as such. However, Python allows to implement abstract class with usage of abc module.
												- we cannot instantiate an abstract class,<br>
												- abstract class defines methods that needs to be implemented in all of the child classes that inherits from it,<br>
												- with using abract classes we can be creating Python's interface-like structures.
											</li>
											<li>Lets set up scenario where there is a big interace that has multiple abstract methods:
												- class that uses that interface needs to implement all of the abstract methods (in Python, it is required by decorator @abstractmethod),<br>
												- however, there may be some abstract methods that our specific class doesn't need to implement,<br>
												- implementing needless method or implementing it as <code>pass</code> violates SOLID principles,<br>
												- following ISP, we would need to divide one main interface to several ones due to their functionality so that classes tha would use them can implement only methods that they need.
											</li>
										</ul>

										<!-- <h5></h5>
										<ul>
											<li></li>
										</ul> -->

									</header>
								</div>
							</section>

						<!-- Two -->
							<section id="two">
								<div class="container">
									<h3>Features</h3>
									<p>App includes following features:</p>
									<ul class="feature-icons">
										<li class="icon solid fa-check">SOLID</li>
										<li class="icon solid fa-check">DRY</li>
										<li class="icon solid fa-check">KISS</li>
									</ul>
								</div>
							</section>

						<!-- Three -->
							<section id="three">
								<div class="container">
									<h3>Demo</h3>

									<h5>...:</h5>
									<ul>
										<li>...</li>
									</ul>

								</div>
							</section>

						<!-- Four -->
							<section id="four">
								<div class="container">
									<h3>Setup</h3>
									<p>No specific installation required.</p>
								</div>
							</section>

						<!-- Five -->
							<section id="five">
								<div class="container">
									<h3>Source Code</h3>
									<p>You can view the source code: <a href="#">HERE</a></p>
									<p>&nbsp</p>
								</div>
							</section>

					</div>

				<!-- Footer -->
					<section id="footer">
						<div class="container">
							<a href="https://arturskrzeta.github.io/" style="padding-bottom:10px;">Back to Portfolio</a>
						</div>
					</section>

			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>
