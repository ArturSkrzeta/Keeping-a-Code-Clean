<!DOCTYPE HTML>

<html>
	<head>
		<title>Portfolio Artur Skrzeta</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
	</head>
	<body class="is-preload">

		<!-- Header -->
			<section id="header">
				<header>
					<span class="image avatar"><a href="https://arturskrzeta.github.io/"><img src="images/avatar.png" alt="" style="margin-bottom:0px;"/></a></span>
					<h1 id="logo"><a href="https://arturskrzeta.github.io/">Artur Skrzeta</a></h1>
					<p>Data Analyst<br />
					+4 years experience</p>
				</header>
				<nav id="nav">
					<ul>
						<li><a href="#one" class="active">Intro</a></li>
						<li><a href="#two">Features</a></li>
						<li><a href="#three">Demo</a></li>
						<li><a href="#four">Setup</a></li>
						<li><a href="#five">Source Code</a></li>
					</ul>
				</nav>
				<footer>
					<ul class="icons">
						<li><a href="https://www.linkedin.com/in/artur-skrz%C4%99ta-010b23187/" class="icon brands fa-linkedin"><span class="label">LinkedIn</span></a></li>
						<li><a href="https://www.instagram.com/arturskrrr/" class="icon brands fa-instagram"><span class="label">Instagram</span></a></li>
						<li><a href="https://github.com/ArturSkrzeta" class="icon brands fa-github"><span class="label">Github</span></a></li>
						<li><a href="mailto: arturskrzeta@gmail.com" class="icon solid fa-envelope"><span class="label">Email</span></a></li
					</ul>
				</footer>
			</section>

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<div id="main">

						<!-- One -->
							<section id="one">
								<div class="container">
									<header class="major">
										<h2>Keeping a Code Clean</h2>
										<h3>Intro</h3>

										<h3>SOLID</h3>

										<h5>Terminology:</h5>
										<ul>
											<li><b>Abstract class</b> is a class that contains one or more abstract methods. They cannot be instantiated and they require subclasses to provide implementations for their abstract methods.</li>
											<li><b>Abstract method</b> is a method that is declared, but contains no implementation. Needs to be implemented by subclasses that inherits them.</li>
<!-- code area start -->
<pre>from abc import ABC, abstractmethod

class Save(ABC):

  @abstractmethod
  def save_data(self):
    print("Saving data...")

class SaveToDb(Save):

  def save_data(self):
    super().do_something()
    print("to database.")

x = SaveToDb()
x.save_data()

-------------------------
output: Saving data...
	to database.</pre>
<!-- code area stop -->
										</ul>

										<h5>Single Responsibility Principle (SRP):</h5>
										<ul>
											<li><code>Every class should only have one responsibility</code><br>
													<code>and therefore only one reason to change.</code></li>
											<li>In other words, a class is responsible for performing only one speciied task.</li>
											<li>Too many tasks within a class would cause to much complexity and change of one task can affect another task's work.</li>
											<li>When multiple tasks in a class and there is a new requirement from the business, it forces us to modify existing code which violates rest of SOLID principles.</li>
											<li>With this SRP, maintaining the code is much easier and readable when handing code over.</li>
											<li>When class perfoms only one task, it is much easiser to test it out.</li>
											<li>SRP enables flexibility in extending the application with new business requirements.</li>
										</ul>

										<h5>Open Closed Principle (OCP):</h5>
										<ul>
											<li><code>Software Entities (classes, functions, modules)</code><br>
													<code>should be open for extension but closed to change.</code></li>
											<li>Without OCP, when a new business requirement comes in, the most common approach is modifing the definition of existing method.</li>
											<li>Keeping modifying definition of extisting functunality we end up testing the enire scope repeatedly.</li>
											<li>When following OCP, instead of modifying, we should extend the aplication to satisfy the new requirement.</li>
											<li>Avoiding modifying, we are less likely to introduce some bugs into the existing code as well as we avoinding redeploying the same code again and again.</li>
											<li>Extension can be achieved by inheritance from parent class where child class satisfies a new requirement.
												<br>
												- child class extends existing parent classes,<br>
												- child class can override definition of parent's methods which covers a new requirements.
											</li>
											<li>We can be keeping an abstract class - the most general one that will never be instantiated but will be a pattern to inherit from by sub-classes where each sub-class answers specific business requirement.</li>
										</ul>

										<h5>Liskov's Substitution Principle (LSP):</h5>
										<ul>
											<li><code>If S is a subtype of T, then objects of type T</code><br>
													<code>may be replaced with objects of Type S.</code></li>
											<li>This principle is strictly related to inheritnace where any child class can replace its parent class without breaking functionality.</li>
											<li>We can define methods in the child class with the same name as defined in their parent class - this is what is called <b>polymorphism</b>.</li>
											<li>Naming methods the same means that the same function can be used by different types/classes that inheritns from a base class.</li>
											<li>Naming methods the same means inheitance of the method by a child class.
												However, there are situations where ingereted method doesn't fit into applicaton or nature of child class.
												In such case there in a need to re-implement the method in the child class which is called the <b>method overriding</b>.</li>
											<li>...</li>
										</ul>

										<h5>Interface Segregation Principle (ISP):</h5>
										<ul>
											<li><code>.</code></li>
										</ul>

									</header>
								</div>
							</section>

						<!-- Two -->
							<section id="two">
								<div class="container">
									<h3>Features</h3>
									<p>App includes following features:</p>
									<ul class="feature-icons">
										<li class="icon solid fa-check">SOLID</li>
										<li class="icon solid fa-check">DRY</li>
										<li class="icon solid fa-check">KISS</li>
									</ul>
								</div>
							</section>

						<!-- Three -->
							<section id="three">
								<div class="container">
									<h3>Demo</h3>

									<h5>...:</h5>
									<ul>
										<li>...</li>
									</ul>

								</div>
							</section>

						<!-- Four -->
							<section id="four">
								<div class="container">
									<h3>Setup</h3>
									<p>No specific installation required.</p>
								</div>
							</section>

						<!-- Five -->
							<section id="five">
								<div class="container">
									<h3>Source Code</h3>
									<p>You can view the source code: <a href="#">HERE</a></p>
									<p>&nbsp</p>
								</div>
							</section>

					</div>

				<!-- Footer -->
					<section id="footer">
						<div class="container">
							<a href="https://arturskrzeta.github.io/" style="padding-bottom:10px;">Back to Portfolio</a>
						</div>
					</section>

			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>
